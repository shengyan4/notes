

# j s复习查漏补缺笔记：

## 基础知识

### [求幂 **](https://zh.javascript.info/operators#qiu-mi)

求幂运算 `a ** b` 将 `a` 提升至 `a` 的 `b` 次幂。

在数学中我们将其表示为 ab。

例如：

```
alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
就像在数学计算中一样，幂运算也适用于非整数。

例如，平方根是指数为 ½ 的幂运算：

alert( 4 ** (1/2) ); // 2（1/2 次方与平方根相同)
alert( 8 ** (1/3) ); // 2（1/3 次方与立方根相同)
```

## [用二元运算符 + 连接字符串](https://zh.javascript.info/operators#yong-er-yuan-yun-suan-fu-lian-jie-zi-fu-chuan)

```
alert(2 + 2 + '1' ); // "41"，不是 "221"
```

在这里，运算符是按顺序工作。第一个 `+` 将两个数字相加，所以返回 `4`，然后下一个 `+` 将字符串 `1` 加入其中，所以就是 `4 + '1' = '41'`。

```
alert('1' + 2 + 2); // "122"，不是 "14"
```

这里，第一个操作数是一个字符串，所以编译器将其他两个操作数也视为了字符串。`2` 被与 `'1'` 连接到了一起，也就是像 `'1' + 2 = "12"` 然后 `"12" + 2 = "122"` 这样。

二元 `+` 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。

下面是减法和除法运算的示例：

```
alert( 6 - '2' ); // 4，将 '2' 转换为数字
alert( '6' / '2' ); // 3，将两个运算元都转换为数字
```



## [数字转化，一元运算符 +](https://zh.javascript.info/operators#shu-zi-zhuan-hua-yi-yuan-yun-suan-fu)

加号 `+` 有两种形式。一种是上面我们刚刚讨论的二元运算符，还有一种是一元运算符。

一元运算符加号，或者说，加号 `+` 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 `+` 则会将其转化为数字。

例如： 

```
// 对数字无效
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 转化非数字
alert( +true ); // 1
alert( +"" );   // 0
```

它的效果和 `Number(...)` 相同，但是更加简短。

我们经常会有将字符串转化为数字的需求。比如，如果我们正在从 HTML 表单中取值，通常得到的都是字符串。如果我们想对它们求和，该怎么办？

二元运算符加号会把它们合并成字符串：

```
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23"，二元运算符加号合并字符串
```

如果我们想把它们当做数字对待，我们需要转化它们，然后再求和：

```
let apples = "2";
let oranges = "3";

// 在二元运算符加号起作用之前，所有的值都被转化为了数字
alert( +apples + +oranges ); // 5

// 更长的写法
// alert( Number(apples) + Number(oranges) ); // 5
```

从一个数学家的视角来看，大量的加号可能很奇怪。但是从一个程序员的视角，没什么好奇怪的：一元运算符加号首先起作用，它们将字符串转为数字，然后二元运算符加号对它们进行求和。

为什么一元运算符先于二元运算符作用于运算元？接下去我们将讨论到，这是由于它们拥有 **更高的优先级**。

| 优先级 | 名称           | 符号   |
| :----- | :------------- | :----- |
| 15     | 自增/自减/等等 | ++，-- |
| 15     | 一元加号       | `+`    |
| 15     | 一元负号       | `-`    |
| 14     | 求幂           | `**`   |
| 13     | 乘号           | `*`    |
| 13     | 除号           | `/`    |
| 12     | 加号           | `+`    |
| 12     | 减号           | `-`    |
| …      | …              | …      |
| 2      | 赋值符         | `=`    |
| 1      | 逗号运算符     | ，     |

我们可以看到，“一元加号运算符”的优先级是 `15`，高于“二元加号运算符”的优先级 `12`。这也是为什么表达式 `"+apples + +oranges"` 中的一元加号先生效，然后才是二元加法。

## [原地修改](https://zh.javascript.info/operators#yuan-di-xiu-gai)

我们经常需要对一个变量做运算，并将新的结果存储在同一个变量中。

例如：

```
let n = 2;
n = n + 5;
n = n * 2;
```

可以使用运算符 `+=` 和 `*=` 来缩写这种表示。

```
let n = 2;
n += 5; // 现在 n = 7（等同于 n = n + 5）
n *= 2; // 现在 n = 14（等同于 n = n * 2）

alert( n ); // 14
```

所有算术和位运算符都有简短的“修改并赋值”运算符：`/=` 和 `-=` 等。

这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：

```
let n = 2;

n *= 3 + 5;

alert( n ); // 16 （右边部分先被计算，等同于 n *= 8）
```

## [自增/自减](https://zh.javascript.info/operators#zi-zeng-zi-jian)

**重要：
自增/自减只能应用于变量。试一下，将其应用于数值（比如 5++）则会报错。`++/--` 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。**

- 如果自增/自减的值不会被使用，那么两者形式没有区别：

  ```
  let counter = 0;
  counter++;
  ++counter;
  alert( counter ); // 2，以上两行作用相同
  ```

- 如果我们想要对变量进行自增操作，**并且** 需要立刻使用自增后的值，那么我们需要使用前置形式：

  ```
  let counter = 0;
  alert( ++counter ); // 1
  ```

- 如果我们想要将一个数加一，但是我们想使用其自增之前的值，那么我们需要使用后置形式：

  ```
  let counter = 0;
  alert( counter++ ); // 0
  ```

## [不同类型间的比较](https://zh.javascript.info/comparison#bu-tong-lei-xing-jian-de-bi-jiao)

当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。

```
alert( '2' > 1 ); // true，字符串 '2' 会被转化为数字 2
alert( '01' == 1 ); // true，字符串 '01' 会被转化为数字 1
```

对于布尔类型值，`true` 会被转化为 `1`、`false` 转化为 `0`。

例如：

```
alert( true == 1 ); // true
alert( false == 0 ); // true
```

## [字符串比较](https://zh.javascript.info/comparison#zi-fu-chuan-bi-jiao)

在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定。

换言之，字符串是按字符（母）逐个进行比较的。

例如：

```javascript
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

字符串的比较算法非常简单：

1. 首先比较两个字符串的首位字符大小。

2. 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。

3. 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。

4. 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。

5. 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。

   > **非真正的字典顺序，而是 Unicode 编码顺序**
   >
   > 在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。
   >
   > 比如说，字符串比较对字母大小写是敏感的。大写的 `"A"` 并不等于小写的 `"a"`。哪一个更大呢？实际上小写的 `"a"` 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大。我们会在 [字符串](https://zh.javascript.info/string) 这章讨论更多关于字符串的细节。

## [对 null 和 undefined 进行比较](https://zh.javascript.info/comparison#dui-null-he-undefined-jin-hang-bi-jiao)

当使用 `null` 或 `undefined` 与其他值进行比较时，其返回结果常常出乎你的意料。

- 当使用严格相等 `===` 比较二者时

  它们不相等，因为它们属于不同的类型。

  ```
  alert( null === undefined ); // false
  ```

- 当使用非严格相等 `==` 比较二者时

  JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。

  ```
  alert( null == undefined ); // true
  ```

- 当使用数学式或其他比较方法 `< > <= >=` 时：

  `null/undefined` 会被转化为数字：`null` 被转化为 `0`，`undefined` 被转化为 `NaN`。

  ### [奇怪的结果：null vs 0](https://zh.javascript.info/comparison#qi-guai-de-jie-guo-nullvs0)

  通过比较 `null` 和 0 可得：

  ```
  alert( null > 0 );  // (1) false
  alert( null == 0 ); // (2) false
  alert( null >= 0 ); // (3) true
  ```

  是的，上面的结果完全打破了你对数学的认识。在最后一行代码显示“`null` 大于等于 0”的情况下，前两行代码中一定会有一个是正确的，然而事实表明它们的结果都是 false。

  为什么会出现这种反常结果，这是因为相等性检查 `==` 和**普通比较符** `> < >= <=` 的代码逻辑是相互独立的。**进行值的比较时，`null` 会被转化为数字**，因此它被转化为了 `0`。这就是为什么（3）中 `null >= 0` 返回值是 true，（1）中 `null > 0` 返回值是 false。

  另一方面，**`undefined` 和 `null` 在相等性检查 `==` 中不会进行任何的类型转换**，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 `null == 0` 会返回 false。

  ### [特立独行的 undefined](https://zh.javascript.info/comparison#te-li-du-hang-de-undefined)

  `undefined` 不应该被与其他值进行比较：

  ```
  alert( undefined > 0 ); // false (1)
  alert( undefined < 0 ); // false (2)
  alert( undefined == 0 ); // false (3)
  ```

  为何它看起来如此厌恶 0？返回值都是 false！

  原因如下：

  - `(1)` 和 `(2)` 都返回 `false` 是因为 `undefined` 在比较中被转换为了 `NaN`，而 `NaN` 是一个特殊的数值型值，它与任何值进行比较都会返回 `false`。
  - `(3)` 返回 `false` 是因为这是一个相等性检查，而 `undefined` 只与 `null` 相等，不会与其他值相等。

### [避免问题](https://zh.javascript.info/comparison#bi-mian-wen-ti)

我们为何要研究上述示例？我们需要时刻记得这些古怪的规则吗？不，其实不需要。虽然随着代码写得越来越多，我们对这些规则也都会烂熟于胸，但是我们需要更为可靠的方法来避免潜在的问题：

- 除了严格相等 `===` 外，其他但凡是有 `undefined/null` 参与的比较，我们都需要格外小心。
- 除非你非常清楚自己在做什么，否则永远不要使用 `>= > < <=` 去比较一个可能为 `null/undefined` 的变量。对于取值可能是 `null/undefined` 的变量，请按需要分别检查它的取值情况。

## [总结](https://zh.javascript.info/comparison#zong-jie)

- 比较运算符始终返回布尔值。
- 字符串的比较，会按照“词典”顺序逐字符地比较大小。
- 当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。
- 在非严格相等 `==` 下，`null` 和 `undefined` 相等且各自不等于任何其他的值。
- 在使用 `>` 或 `<` 进行比较时，需要注意变量可能为 `null/undefined` 的情况。比较好的方法是单独检查变量是否等于 `null/undefined`。

# 逻辑运算符

# 空值合并运算符 '??'

- 空值合并运算符 `??` 提供了一种从列表中选择第一个“已定义的”值的简便方式。

  它被用于为变量分配默认值：

  ```javascript
  // 当 height 的值为 null 或 undefined 时，将 height 的值设置为 100
  height = height ?? 100;
  ```

- `??` 运算符的优先级非常低，仅略高于 `?` 和 `=`，因此在表达式中使用它时请考虑添加括号。

- 如果没有明确添加括号，不能将其与 `||` 或 `&&` 一起使用。
